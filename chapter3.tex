\chapter{РЕЗУЛЬТАТЫ ЧИСЛЕННЫХ ЭКСПЕРИМЕНТОВ}\label{chap3}

В качестве примера, иллюстрирующего алгоритм построения обратной связи в реальном времени для централизованного случая, будем рассматривать задачу оптимального управления для объекта, состоящего из трех взаимосвязанных систем и описываемого линейными уравнениями с аддитивными возмущениями $w$:
\begin{align}
\ddot{z_1} &= -2kz_1 + kz_2 + u_1 + w_1,\notag \\
\ddot{z_2} &= -2kz_2 + kz_1 + kz_3 + u_2 + w_2,\label{connected_systems}\\ 
\ddot{z_3} &= -2kz_3 + kz_2 + u_3 + w_3. \notag
\end{align}

Управляющее воздействия ограничены по модулю $|u_i(t)| \le L, t\in [t_0,t_f], i \in I = \{1, \ 2, \ 3\}$, и в момент времени $t_f$ требуется перевести объект (\ref{connected_systems}) на терминальное множество, задаваемое ограничениями $|z_i(t_f)| \le d_1, \ |\dot{z_i}(t_f)| \le d_2, i \in I$, а критерий качества имеет вид:
\[
	\int\limits_{t_0}^{t_f} \sum_{i \in I} |u_i(t)|\,dt \to min.
\]

Параметры задачи выберем следующим образом: $k = 10,\ L = 1,\ t_0 = 0,\ t_f = 4.5;\ d_i = 0.1,\ \dot{z_i}(0) = 1,\ z_i(0) = 1,\ i \in I$. Пусть также $ |T_h| = 100$, $w(t) = 
\begin{pmatrix}
	0.7\,sin\,2t\\
	0.1\,cos\,t\\
	-0.05\,cos\,3t\\
\end{pmatrix}.$



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Сведение задачи к задаче линейного программирования}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В отличие от разобранного ранее случая, в данной задаче добавилось возмущение $w(t)$, однако это не сильно влияет на алгоритм построения решения, разве что на построение траектории. 

Произведем замену: 
\begin{align}
x_1 &= z_1, \qquad x_3 = z_2, \qquad x_5 = z_3, \notag \\
x_2 &= \dot{z_1}, \qquad x_4 = \dot{z_2}, \qquad x_6 = \dot{z_3}.\notag
\end{align} Введем переменные $n = 6$ -- число равенств замены; $r = 3$ -- число взаимосвязанных систем; $m = 2n$ -- число ограничений на $x_i, \ i = 1...n$. Тогда видно, что задача имеет вид (см главу 2):
\begin{equation} \label{form_of_the_task}
\int\limits_{t_0}^{t_f} \sum_{i \in I} |u_i(t)|\,dt \to min,
\end{equation}
\[
	\dot{x}(t) = Ax(t) + Bu(t) + Mw(t),
\]
\[
	x(0) = x_0, \ t \in [t_0, t_f], \ Hx(t_f) \le g,
\]
где 
\[
	A = \begin{pmatrix}
	0 & 1 & 0 & 0 & 0 & 0 \\
	-2k & 0 & k & 0 & 0 & 0 \\
	0 & 0 & 0 & 1 & 0 & 0 \\
	k & 0 & -2k & 0 & k & 0 \\
	0 & 0 & 0 & 0 & 0 & 1 \\
	0 & 0 & k & 0 & -2k & 0 \\
	\end{pmatrix}, \ 	
	B = M = \begin{pmatrix}
	0 & 0 & 0 \\
	1 & 0 & 0 \\
	0 & 0 & 0 \\
	0 & 1 & 0 \\
	0 & 0 & 0 \\
	0 & 0 & 1 \\
	\end{pmatrix}, \ 	
	x_0 = \begin{pmatrix}
	1\\ 1\\ 1\\ 1\\ 1\\ 1\\
	\end{pmatrix},
\]
\[
H = \begin{pmatrix}
	1 & 0 & 0 & 0 & 0 & 0 \\
	0 & 1 & 0 & 0 & 0 & 0 \\
	0 & 0 & 1 & 0 & 0 & 0 \\
	0 & 0 & 0 & 1 & 0 & 0 \\
	0 & 0 & 0 & 0 & 1 & 0 \\
	0 & 0 & 0 & 0 & 0 & 1 \\
	-1 & 0 & 0 & 0 & 0 & 0 \\
	0 & -1 & 0 & 0 & 0 & 0 \\
	0 & 0 & -1 & 0 & 0 & 0 \\
	0 & 0 & 0 & -1 & 0 & 0 \\
	0 & 0 & 0 & 0 & -1 & 0 \\
	0 & 0 & 0 & 0 & 0 & -1 \\
	\end{pmatrix}, \ 
	g = \begin{pmatrix}
	0.1 \\0.1 \\0.1 \\0.1 \\0.1 \\0.1 \\
	0.1 \\0.1 \\0.1 \\0.1 \\0.1 \\0.1 \\
	\end{pmatrix}.
\]


Используя последовательный подход, сведем задачу (\ref{form_of_the_task}) к задаче линейного программирования, аналогично тому, как сводили задачу (\ref{main_task}) к задаче (\ref{task_in_LP}). Если после этого применить замену $u(s) = z(s) - v(s), s \in T_h$, то в итоге задачу (\ref{form_of_the_task}) можно записать следующим образом:

\begin{equation}\label{task_for_linprog}
	\sum_{s \in T_h} 
	c'
	\begin{pmatrix} z(s) \\ v(s) \\ \end{pmatrix} \to min,
\end{equation}
\[
	\sum_{s \in T_h} 
	(d_h(s), -d_h(s))
	\begin{pmatrix} z(s) \\ v(s) \\ \end{pmatrix}  \le \tilde g,
\] где 
$c = \begin{pmatrix} 
1 \\ \vdots \\  1 \\
\end{pmatrix}\in  \R^{2r}$;
	$d_h(s)$ и $\tilde g$ задаются аналогично тому, как они задавались во второй главе:
$
	d_h(s) = \int\limits_{s}^{s+h} H F(t_f,\theta)B(\theta)\,d\theta,\  d_h(s) \in \R^{m \times r};
    $
$
	\tilde g = g - H F(t_f, t_0)x_0 , \tilde g \in  \R^{m}.
	$

   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Построение обратной связи и соответствующей траектории} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Построение программного решения --- первый шаг для построения обратной связи.


Для записи левой части ограничений задачи (\ref{task_for_linprog}) в матричном виде в функции
\begin{lstlisting}
function Ale = Form_LP()
        
    for_d = @(t)H*F(t_f-t)*b;
    get_d_h = @(s)integral(for_d,s,s+h,'ArrayValued', true);
    d_h_values = zeros(m, r, N_initial);
    
    for i = 1:N_initial
        d_h_values(:,:,i) = get_d_h(t_0 + i*h-h);
    end
    
    Ale = [];
    for i = 1:N_initial
        Ale = [Ale  d_h_values(:,:,i) -d_h_values(:,:,i)];
    end
end
\end{lstlisting}
формируется матрица \mcode{Ale} (строки 11-14), которая будет иметь вид:
\begin{equation}\label{Ale}
\begin{pmatrix}
	d_h(t_0) & -d_h(t_0) &  \dots & d_h(t_f) & -d_h(t_f)
	\end{pmatrix}. 
\end{equation}


Матрица \mcode{Ale} будет являться одним из параметров стандартной процедуры linprog для решения задач линейного программирования. 


В функции 
\begin{lstlisting}
function u = P(tau, z)
    
    N = round((t_f - tau)/h);%new N for new  tau
    
    g_wave = g - H * F(t_f - tau) * z;

    c = ones(1, 2*r*N);

    ub = L*ones(2*r*N, 1);

    startBlockNumber = N_initial - N + 1; % 1...N_initial
    
    Opt=optimset('TolFun',1e-9,'TolX',1e-9);
    
    z_and_v = linprog(c,Ale(:,2*r*startBlockNumber - 5 : 2*r*N_initial),g_wave,[],[],zeros(2*r*N, 1),ub,Opt);
    
    zv = reshape(z_and_v, 2*r, N);
    u  = zv(1:r,:) - zv(r+1:2*r,:); % r /times N
end
\end{lstlisting}
определяется оптимальная программа для позиции \mcode{(tau, z)}. Входным параметром является позиция \mcode{(tau, z)}. 


Результатом стандартной процедуры linprog будет вектор \mcode{z_and_v}, который можно записать в виде:
\[
 \begin{pmatrix}
	z(\tau) \\ v(\tau) \\ 
	z(\tau + h) \\ v(\tau + h) \\  \vdots \\
	z(t_f) \\ v(t_f)
\end{pmatrix}.
\]
Вектор преобразуется в позиционное решение строками кода под номером 17 и 18. 


То есть для получения программного решения позиции \mcode{(tau, z)} достаточно один раз вызвать функцию \mcode{function u = P(tau, z)}. Оно вместе с соотвествующей траекторией строится для сравнения с оптимальной обратной связью в части кода, записанной ниже:

\begin{lstlisting}
U_0 = P(t_0, x_0);

X_0 = trajectory(x_0, t_0, t_f, U_0);

\end{lstlisting}


Функция
\begin{lstlisting}
function x = trajectory(x0, t_begin, t_end, u)
    N = round((t_end - t_begin)/h);
    x = zeros(n, N);
    x(:,1) = x0;
    for j = 1:N
        curr = t_begin + (j-1)*h;
        next = t_begin + j*h;
        x(:, j+1) = F(h) * x(:,j) +  integral(@(t) F(next - t)*b,curr, next, 'ArrayValued', true,'RelTol',0,'AbsTol',1e-12)*u(:, j) + integral(@(t) F(curr - t)* M * w(t), curr, next,'ArrayValued', true,'RelTol',0,'AbsTol',1e-12);
    end
end
\end{lstlisting}
принимает параметры для построения траектории: \mcode{x0} --- начальное состояние, \mcode{t_begin, t_end, u} --- начало, конец управление и само управление. Она возвращает траекторию для указанного отрезка времени.


Оптимальная обратная связь ищется в соответсвии с описанным ранее (в главе 2) алгоритмом следующим образом:
\begin{lstlisting}
X = zeros(n, N_initial);

X(:, 1) = x_0;

U = zeros(r, N_initial);

for k = 1:N_initial
    tau = t_0 + (k - 1)*h;
    
    u_res = P(tau, X(:, k));
    
    U(:, k) = u_res(:, 1);
    
    step_trajectory = trajectory(X(:, k), tau, tau + h, U(:, k));
    
    X(:, k + 1) = step_trajectory(:,2);
end
\end{lstlisting}

	
Стоит заметить, что в функции \mcode{function u = P(tau, z)} для отыскания позиционного решения для позиции \mcode{(tau, z)} в процедуру linprog вноситься часть уже построенной (функцией \mcode{function Ale = Form_LP()} ) матрицы \mcode{Ale}. Для позиции \mcode{(t_0, x_0)} в linprog подается матрица вида (\ref{Ale}), однако для следующей позиции \mcode{(t_0 + h, X(:, 2))} в linprog вносится матрица без первых $2r$ столбцов:


\[
\begin{pmatrix}
	d_h(t_1) & -d_h(t_1) &  \dots & d_h(t_f) & -d_h(t_f)
\end{pmatrix}. 
\]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Результаты. Сравнение с программным решением} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для оценки резульатов перенесем полученные траектории на фазовые графики. Для $r$ объектов управления получится $r$ фазовых графиков (программное решение отмечено курсивом):


\begin{figure}
    \centering
    \scalebox{.8}{\includegraphics{x}}
    \caption{Фазовые графики}
\end{figure}


\begin{figure}
    \centering
    \scalebox{.8}{\includegraphics{u}}
    \caption{Соответствующие фазовым графикам управления}
\end{figure}


На фазовых графиках видно, что траектории не попадают на терминальное множество. Это происходит из-за наличия неучтенных возмущений $w$, вносимых в систему на протяжении времени управления. При построении оптимальных обратных связей эти возмущения учитываются посредством уточнения состояния системы для каждого момента $\tau \in T_h$.


Таким образом разобрали задачу оптимального управления для объекта, состоящего из трех взаимосвязанных систем, свели данную задачу (\ref{connected_systems}) к задаче линейного программирования, построили программное решение и обратную связь, вывели фазовые графики и сравнили решения.